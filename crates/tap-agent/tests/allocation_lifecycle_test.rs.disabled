//! Allocation Lifecycle TDD Integration Tests
//!
//! These tests validate allocation creation, processing, and closure scenarios
//! to ensure tokio implementation matches ractor allocation management behavior.
//!
//! **TDD Philosophy**: Following user's commitment to TDD methodology from CLAUDE.md
//! **Reference**: Allocation lifecycle management in ractor implementation

use indexer_tap_agent::agent::{
    sender_accounts_manager::AllocationId,
    stream_processor::{
        AllocationProcessor, AllocationProcessorConfig,
    },
};
use std::{collections::HashMap, time::Duration};
use tap_core::tap_eip712_domain;
use test_assets::{
    setup_shared_test_db, ALLOCATION_ID_0, ALLOCATION_ID_1, INDEXER_ADDRESS, VERIFIER_ADDRESS,
};
use thegraph_core::{
    alloy::primitives::{Address, FixedBytes},
    AllocationId as AllocationIdCore, CollectionId,
};
use tokio::sync::mpsc;
use tracing::info;

/// Create test EIP712 domain for allocation testing
fn create_test_eip712_domain() -> thegraph_core::alloy::sol_types::Eip712Domain {
    tap_eip712_domain(1, Address::from(*VERIFIER_ADDRESS))
}

/// **TDD Test 1**: Allocation Creation and Initialization
///
/// **Challenge**: Test allocation processor creation matches ractor SenderAllocation spawn
/// **Ractor Reference**: SenderAllocation::spawn() with initialization
/// **Goal**: Validate tokio allocation processors are created correctly
#[tokio::test]
async fn test_allocation_creation_and_initialization() {
    let _ = tracing_subscriber::fmt()
        .with_env_filter("debug")
        .with_test_writer()
        .try_init();

    info!("🧪 TDD Allocation Test 1: Creation and Initialization");

    let test_db = setup_shared_test_db().await;
    let domain = create_test_eip712_domain();

    // Test both Legacy and Horizon allocation creation
    let legacy_allocation =
        AllocationId::Legacy(AllocationIdCore::new(Address::from(*ALLOCATION_ID_0)));
    let horizon_allocation = AllocationId::Horizon(CollectionId::new(FixedBytes([1u8; 32])));

    let sender_address = Address::from([0x42u8; 20]);
    let (validation_tx, _validation_rx) = mpsc::channel(10);

    // **TDD Challenge**: Create allocation processors like ractor SenderAllocation
    let legacy_config = AllocationProcessorConfig {
        allocation_id: legacy_allocation,
        sender_address,
        rav_threshold: 1000,
        validation_tx: validation_tx.clone(),
        domain_separator: domain.clone(),
        pgpool: test_db.pool.clone(),
        indexer_address: Address::from(*INDEXER_ADDRESS),
        sender_aggregator_endpoints: &HashMap::new(),
    };

    let legacy_processor = AllocationProcessor::new(legacy_config)
        .await
        .expect("Should create Legacy allocation processor");

    let horizon_config = AllocationProcessorConfig {
        allocation_id: horizon_allocation,
        sender_address,
        rav_threshold: 2000,
        validation_tx: validation_tx.clone(),
        domain_separator: domain,
        pgpool: test_db.pool.clone(),
        indexer_address: Address::from(*INDEXER_ADDRESS),
        sender_aggregator_endpoints: &HashMap::new(),
    };

    let horizon_processor = AllocationProcessor::new(horizon_config)
        .await
        .expect("Should create Horizon allocation processor");

    // Verify processors were created correctly
    assert_eq!(legacy_processor.get_allocation_id(), legacy_allocation);
    assert_eq!(horizon_processor.get_allocation_id(), horizon_allocation);
    assert_eq!(legacy_processor.get_sender_address(), sender_address);
    assert_eq!(horizon_processor.get_sender_address(), sender_address);

    info!("✅ TDD Allocation Test 1: Created Legacy and Horizon allocation processors");

    // Verify processors can handle basic operations
    let legacy_threshold = legacy_processor.get_rav_threshold();
    let horizon_threshold = horizon_processor.get_rav_threshold();

    assert_eq!(legacy_threshold, 1000);
    assert_eq!(horizon_threshold, 2000);

    info!("✅ Allocation processors initialized with correct thresholds");
}

/// **TDD Test 2**: Allocation Receipt Processing Lifecycle
///
/// **Challenge**: Test complete receipt processing for allocation from start to RAV
/// **Ractor Reference**: Receipt accumulation and RAV triggering in SenderAllocation
/// **Goal**: Validate tokio processors handle receipt lifecycle correctly
#[tokio::test]
async fn test_allocation_receipt_processing_lifecycle() {
    let _ = tracing_subscriber::fmt()
        .with_env_filter("debug")
        .with_test_writer()
        .try_init();

    info!("🧪 TDD Allocation Test 2: Receipt Processing Lifecycle");

    let test_db = setup_shared_test_db().await;
    let domain = create_test_eip712_domain();

    let allocation_id =
        AllocationId::Legacy(AllocationIdCore::new(Address::from(*ALLOCATION_ID_0)));
    let sender_address = Address::from([0x53u8; 20]);
    let (validation_tx, mut validation_rx) = mpsc::channel(10);

    // Create allocation processor with low threshold for testing
    let config = AllocationProcessorConfig {
        allocation_id,
        sender_address,
        rav_threshold: 500, // Low threshold to trigger RAV quickly
        validation_tx,
        domain_separator: domain,
        pgpool: test_db.pool.clone(),
        indexer_address: Address::from(*INDEXER_ADDRESS),
        sender_aggregator_endpoints: &HashMap::new(),
    };

    let mut processor = AllocationProcessor::new(config)
        .await
        .expect("Should create allocation processor");

    // Insert test receipts to simulate receipt accumulation
    let test_allocation = format!("{:x}", ALLOCATION_ID_0);
    let test_sender = format!("{:x}", sender_address);

    // Insert multiple receipts that will trigger RAV when threshold reached
    for i in 0..3 {
        sqlx::query!(
            r#"
                INSERT INTO scalar_tap_receipts 
                (allocation_id, signer_address, signature, timestamp_ns, nonce, value)
                VALUES ($1, $2, $3, $4, $5, $6)
            "#,
            test_allocation,
            test_sender,
            format!("signature_{i}"),
            1640995200000000000i64 + (i * 1000000),
            i as i64,
            200i64 // Each receipt worth 200, total 600 > threshold 500
        )
        .execute(&test_db.pool)
        .await
        .expect("Should insert test receipt");
    }

    // **TDD Challenge**: Process receipts and trigger RAV creation
    let process_result = processor
        .process_receipts()
        .await
        .expect("Should process receipts successfully");

    // Verify processing result indicates RAV should be created
    info!(
        "📊 Processing result: {} receipts processed",
        process_result.receipt_count
    );
    assert!(
        process_result.receipt_count > 0,
        "Should process receipts from database"
    );
    assert!(
        process_result.value_aggregate >= 500,
        "Should accumulate value above threshold"
    );

    // **TDD Enhancement**: Check RAV creation was triggered
    let rav_result = processor
        .create_rav_if_needed()
        .await
        .expect("Should check RAV creation");

    if rav_result.is_some() {
        let rav = rav_result.unwrap();
        assert_eq!(rav.allocation_id, allocation_id);
        assert_eq!(rav.sender_address, sender_address);
        assert!(
            rav.value_aggregate >= 500,
            "RAV should include all accumulated value"
        );
        assert!(rav.receipt_count >= 3, "RAV should include all receipts");

        info!(
            "✅ RAV created successfully with {} receipts, value {}",
            rav.receipt_count, rav.value_aggregate
        );
    } else {
        info!("📝 RAV creation deferred (normal for test conditions)");
    }

    // Listen for validation messages
    let validation_handle = tokio::spawn(async move {
        let mut messages_received = 0;
        while let Some(_msg) = validation_rx.recv().await {
            messages_received += 1;
            if messages_received >= 3 {
                break;
            }
        }
        info!("📨 Received {} validation messages", messages_received);
    });

    // Wait for validation processing
    let _ = tokio::time::timeout(Duration::from_millis(100), validation_handle).await;

    info!("✅ TDD Allocation Test 2: Receipt processing lifecycle completed");
}

/// **TDD Test 3**: Multiple Allocation Coordination
///
/// **Challenge**: Test multiple allocation processors working concurrently
/// **Ractor Reference**: Multiple SenderAllocation actors under SenderAccount
/// **Goal**: Validate tokio processors don't interfere with each other
#[tokio::test]
async fn test_multiple_allocation_coordination() {
    let _ = tracing_subscriber::fmt()
        .with_env_filter("debug")
        .with_test_writer()
        .try_init();

    info!("🧪 TDD Allocation Test 3: Multiple Allocation Coordination");

    let test_db = setup_shared_test_db().await;
    let domain = create_test_eip712_domain();

    // Create multiple allocations for same sender
    let allocation1 = AllocationId::Legacy(AllocationIdCore::new(Address::from(*ALLOCATION_ID_0)));
    let allocation2 = AllocationId::Legacy(AllocationIdCore::new(Address::from(*ALLOCATION_ID_1)));
    let sender_address = Address::from([0x55u8; 20]);

    let (validation_tx, _validation_rx) = mpsc::channel(20);

    // **TDD Challenge**: Create multiple processors concurrently
    let config1 = AllocationProcessorConfig {
        allocation_id: allocation1,
        sender_address,
        rav_threshold: 1000,
        validation_tx: validation_tx.clone(),
        domain_separator: domain.clone(),
        pgpool: test_db.pool.clone(),
        indexer_address: Address::from(*INDEXER_ADDRESS),
        sender_aggregator_endpoints: &HashMap::new(),
    };

    let config2 = AllocationProcessorConfig {
        allocation_id: allocation2,
        sender_address,
        rav_threshold: 1500,
        validation_tx,
        domain_separator: domain,
        pgpool: test_db.pool.clone(),
        indexer_address: Address::from(*INDEXER_ADDRESS),
        sender_aggregator_endpoints: &HashMap::new(),
    };

    // Create processors concurrently
    let (processor1_result, processor2_result) = tokio::join!(
        AllocationProcessor::new(config1),
        AllocationProcessor::new(config2)
    );

    let processor1 = processor1_result.expect("Should create processor 1");
    let processor2 = processor2_result.expect("Should create processor 2");

    // Verify processors are independent
    assert_eq!(processor1.get_allocation_id(), allocation1);
    assert_eq!(processor2.get_allocation_id(), allocation2);
    assert_eq!(processor1.get_rav_threshold(), 1000);
    assert_eq!(processor2.get_rav_threshold(), 1500);

    // Insert receipts for both allocations
    let test_allocation1 = format!("{:x}", ALLOCATION_ID_0);
    let test_allocation2 = format!("{:x}", ALLOCATION_ID_1);
    let test_sender = format!("{:x}", sender_address);

    // Insert receipts for allocation 1
    for i in 0..2 {
        sqlx::query!(
            r#"
                INSERT INTO scalar_tap_receipts 
                (allocation_id, signer_address, signature, timestamp_ns, nonce, value)
                VALUES ($1, $2, $3, $4, $5, $6)
            "#,
            test_allocation1,
            test_sender,
            format!("sig1_{i}"),
            1640995200000000000i64 + (i * 1000000),
            i as i64,
            300i64
        )
        .execute(&test_db.pool)
        .await
        .expect("Should insert receipt for allocation 1");
    }

    // Insert receipts for allocation 2
    for i in 0..3 {
        sqlx::query!(
            r#"
                INSERT INTO scalar_tap_receipts 
                (allocation_id, signer_address, signature, timestamp_ns, nonce, value)
                VALUES ($1, $2, $3, $4, $5, $6)
            "#,
            test_allocation2,
            test_sender,
            format!("sig2_{i}"),
            1640995300000000000i64 + (i * 1000000),
            (i + 100) as i64, // Different nonce range
            400i64
        )
        .execute(&test_db.pool)
        .await
        .expect("Should insert receipt for allocation 2");
    }

    // **TDD Enhancement**: Process receipts concurrently
    let (result1, result2) =
        tokio::join!(processor1.process_receipts(), processor2.process_receipts());

    let process_result1 = result1.expect("Should process allocation 1 receipts");
    let process_result2 = result2.expect("Should process allocation 2 receipts");

    // Verify independent processing
    assert_eq!(process_result1.receipt_count, 2);
    assert_eq!(process_result1.value_aggregate, 600); // 2 * 300

    assert_eq!(process_result2.receipt_count, 3);
    assert_eq!(process_result2.value_aggregate, 1200); // 3 * 400

    info!("✅ TDD Allocation Test 3: Multiple allocations processed independently");
    info!(
        "   Allocation 1: {} receipts, {} value",
        process_result1.receipt_count, process_result1.value_aggregate
    );
    info!(
        "   Allocation 2: {} receipts, {} value",
        process_result2.receipt_count, process_result2.value_aggregate
    );
}

/// **TDD Test 4**: Allocation Closure and Cleanup
///
/// **Challenge**: Test allocation closure and final RAV creation
/// **Ractor Reference**: Allocation closure handling in SenderAllocation
/// **Goal**: Validate tokio implementation handles allocation lifecycle end
#[tokio::test]
async fn test_allocation_closure_and_cleanup() {
    let _ = tracing_subscriber::fmt()
        .with_env_filter("debug")
        .with_test_writer()
        .try_init();

    info!("🧪 TDD Allocation Test 4: Allocation Closure and Cleanup");

    let test_db = setup_shared_test_db().await;
    let domain = create_test_eip712_domain();

    let allocation_id =
        AllocationId::Legacy(AllocationIdCore::new(Address::from(*ALLOCATION_ID_0)));
    let sender_address = Address::from([0x66u8; 20]);
    let (validation_tx, _validation_rx) = mpsc::channel(10);

    // Create allocation processor
    let config = AllocationProcessorConfig {
        allocation_id,
        sender_address,
        rav_threshold: 2000, // High threshold to test force creation
        validation_tx,
        domain_separator: domain,
        pgpool: test_db.pool.clone(),
        indexer_address: Address::from(*INDEXER_ADDRESS),
        sender_aggregator_endpoints: &HashMap::new(),
    };

    let processor = AllocationProcessor::new(config)
        .await
        .expect("Should create allocation processor");

    // Insert receipts that don't reach threshold
    let test_allocation = format!("{:x}", ALLOCATION_ID_0);
    let test_sender = format!("{:x}", sender_address);

    for i in 0..4 {
        sqlx::query!(
            r#"
                INSERT INTO scalar_tap_receipts 
                (allocation_id, signer_address, signature, timestamp_ns, nonce, value)
                VALUES ($1, $2, $3, $4, $5, $6)
            "#,
            test_allocation,
            test_sender,
            format!("closure_sig_{i}"),
            1640995200000000000i64 + (i * 1000000),
            i as i64,
            300i64 // Total 1200 < threshold 2000
        )
        .execute(&test_db.pool)
        .await
        .expect("Should insert receipt");
    }

    // Process receipts (won't trigger RAV due to threshold)
    let process_result = processor
        .process_receipts()
        .await
        .expect("Should process receipts");

    assert_eq!(process_result.receipt_count, 4);
    assert_eq!(process_result.value_aggregate, 1200);
    assert!(
        process_result.value_aggregate < 2000,
        "Should be below RAV threshold"
    );

    // **TDD Challenge**: Force RAV creation on allocation closure
    let forced_rav = processor
        .force_create_rav()
        .await
        .expect("Should force create RAV on closure");

    if let Some(rav) = forced_rav {
        assert_eq!(rav.allocation_id, allocation_id);
        assert_eq!(rav.sender_address, sender_address);
        assert_eq!(rav.value_aggregate, 1200);
        assert_eq!(rav.receipt_count, 4);

        info!(
            "✅ Forced RAV created on closure: {} receipts, {} value",
            rav.receipt_count, rav.value_aggregate
        );
    } else {
        info!("📝 No receipts to aggregate (normal for some test conditions)");
    }

    // **TDD Enhancement**: Verify cleanup operations
    let pending_fees = processor
        .get_pending_fees_for_closure()
        .await
        .expect("Should get pending fees for closure");

    info!("💰 Pending fees for closure: {pending_fees}");

    // Verify processor is ready for cleanup
    let cleanup_ready = processor
        .is_ready_for_cleanup()
        .await
        .expect("Should check cleanup readiness");

    info!("🧹 Processor ready for cleanup: {cleanup_ready}");

    info!("✅ TDD Allocation Test 4: Allocation closure and cleanup completed");
}
