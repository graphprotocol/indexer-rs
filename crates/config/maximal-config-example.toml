# WARNING:  This shows all the possible configuration options. Make sure you know what
#           you are doing.
#           Prefer starting with `minimal-config-example.toml`.
#
# All the optional values (missing from the minimal config) are set to the current
# default values.
# You will have to change *most* the values below to match your setup.
#
# Some of the config below are global graph network values, which you can find here:
# https://github.com/graphprotocol/indexer/tree/main/docs/networks
#
# If you want to supply some or all of the configuration below using environment variables,
# use the prefix "INDEXER_SERVICE" or "TAP_AGENT" for indexer-service or tap-agent, respectively,
# followed by the name of the field, using double underscores "__" for nesting. Example:
#
#       INDEXER_SERVICE_SUBGRAPHS__NETWORK__QUERY_URL = [...]
#
#   For
#
#       [subgraphs.network]
#       query_url = [...]

[indexer]
indexer_address = "0x1111111111111111111111111111111111111111"
# Single operator mnemonic (for most setups)
operator_mnemonic = "celery smart tip orange scare van steel radio dragon joy alarm crane"
# For key rotation or migration, you can specify multiple mnemonics.
# All configured mnemonics are tried when creating attestation signers,
# allowing allocations created with different operator keys to work.
#
# Notes:
# - The first mnemonic (from operator_mnemonic, or first in operator_mnemonics)
#   is used as the "primary" identity shown on the /info endpoint.
# - Both fields can be used together; duplicates are automatically ignored.
# - Order matters: put your current/primary mnemonic first.
#
# operator_mnemonics = [
#     "previous mnemonic phrase here if you rotated keys"
# ]

[metrics]
# Port to serve metrics. This one should stay private.
port = 7300

[database]
# The URL of the Postgres database used for the indexer components. The same database
# that is used by the `indexer-agent`. It is expected that `indexer-agent` will create
# the necessary tables.
postgres_url = "postgres://postgres@postgres:5432/postgres"
# You can also use the following fields to specify the connection details separately.
# either use `postgres_url` or the following fields.
# host = "postgres-host"
# port = 5432
# user = "user"
# password = "pwd"
# database = "postgres"

[graph_node]
# URL to your graph-node's query endpoint
query_url = "http://graph-node:8000"
# URL to your graph-node's status endpoint
status_url = "http://graph-node:8000/graphql"

[subgraphs.network]
# Query URL for the Graph Network subgraph.
query_url = "http://example.com/network-subgraph"
# Optional, Auth token will used a "bearer auth"
# query_auth_token = "super-secret"

# Optional, deployment to look for in the local `graph-node`, if locally indexed.
# Locally indexing the subgraph is recommended.
# NOTE: Use `query_url` or `deployment_id` only
deployment_id = "Qmaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
# Refreshing interval for the Graph contracts information from the Graph Network
# subgraph.
syncing_interval_secs = 60
# Amount of time to keep treating an allocation as active after it has been closed.
# So that we can keep serving queries while the information about the allocation closure
# propagates to all the consumers.
recently_closed_allocation_buffer_secs = 3600
# Maximum allowed age of network subgraph data in minutes.
# Responses older than this are rejected to prevent stale data from replacing fresh data.
# This protects against Gateway routing queries to indexers that are significantly behind.
# Set to 0 to disable staleness checking.
max_data_staleness_mins = 30

[subgraphs.escrow]
# NOTE: It is heavily recomended to use both `query_url` and `deployment_id`,
# Query URL for the Escrow subgraph (v1). This is the old escrow subgraph.
# NOTE: This is not used in v2, as the escrow subgraph is now in the network subgraph.
query_url = "http://example.com/escrow-subgraph"
# Optional, Auth token will used a "bearer auth"
# query_auth_token = "super-secret"

# Optional, deployment to look for in the local `graph-node`, if locally indexed.
# Locally indexing the subgraph is recommended.
deployment_id = "Qmaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
# Refreshing interval for the Escrow contracts information from the Escrow subgraph.
syncing_interval_secs = 60

# NOTE: V2 escrow accounts are now in the network subgraph, not a separate escrow_v2 subgraph

[blockchain]
# The chain ID of the network that the graph network is running on
chain_id = 1337
# Horizon addresses; required when [horizon].enabled = true
receipts_verifier_address_v2 = "0x3333333333333333333333333333333333333333"
subgraph_service_address = "0xcf7ed3acca5a467e9e704c703e8d87f634fb0fc9"

##############################################
# Specific configurations to indexer-service #
##############################################
[service]
# Host and port to serve the indexer-service query endpoint. This one should have a
# public ingress.
host_and_port = "0.0.0.0:7600"
# URL prefix for the query endpoint.
url_prefix = "/"
# Serve the network subgraph on `common.server.host_and_port`/network
serve_network_subgraph = false
# Serve the escrow subgraph on `common.server.host_and_port`/escrow
serve_escrow_subgraph = false
#### OPTIONAL VALUES ####
## use this to add a layer while serving network/escrow subgraph
# serve_auth_token = "token"
## allow queries using this token
# free_query_auth_token = "i-am-authorized-right?"
ipfs_url = "https://api.thegraph.com/ipfs/"
# Maximum number of deployments allowed in a single /cost GraphQL batch query.
# Prevents DoS attacks via unbounded input. Adjust if you serve many subgraphs.
max_cost_model_batch_size = 200
# Maximum request body size in bytes for query endpoints.
# Prevents DoS attacks via unbounded request buffering.
# Default: 2MB (2097152 bytes). Increase if you need to support larger GraphQL queries.
max_request_body_size = 2097152


[service.tap]
# Maximum value of a receipt, in GRT wei.
# We need this because a large receipt, especially if it's larger than the RAV request trigger,
# or worse, the unaggregated receipts limit (tap-agent), can cause the indexer to refuse service
# to the sender for the duration of RAV request timestamp buffer.
max_receipt_value_grt = "0.001" # 0.001 GRT. We use strings to prevent rounding errors

########################################
# Specific configurations to tap-agent #
########################################
[tap]
# This is the amount of fees you are willing to risk at any given time. For ex.
# if the sender stops supplying RAVs for long enough and the fees exceed this
# amount, the indexer-service will stop accepting queries from the sender
# until the fees are aggregated.
# NOTE: Use strings for decimal values to prevent rounding errors
# e.g:
# max_amount_willing_to_lose_grt = "0.1"
max_amount_willing_to_lose_grt = 20

# List of Senders that are allowed to spend up to `max_amount_willing_to_lose_grt`
# over the escrow balance
trusted_senders = ["0xdeadbeefcafebabedeadbeefcafebabedeadbeef"]


# Receipts query timeout
sender_timeout_secs = 30

[tap.rav_request]
# Trigger value is the amount used to trigger a rav request
# The dividor is used to define the trigger value of a RAV request using
# the following formula:
#
#   max_amount_willing_to_lose_grt / trigger_value_divisor = trigger_value
#
# Must be value greater than 1, but recommended to be 10 or more
trigger_value_divisor = 10
# Buffer (in seconds) to add between the current time and the timestamp of the
# last unaggregated fee when triggering a RAV request.
timestamp_buffer_secs = 60
# Timeout (in seconds) for RAV requests.
request_timeout_secs = 5
# Maximum number of receipts per aggregation request
max_receipts_per_request = 10000

[tap.sender_aggregator_endpoints]
# Key-Value of all senders and their aggregator endpoints
0xDDE4cfFd3D9052A9cb618fC05a1Cd02be1f2F467 = "https://tap-aggregator.network.thegraph.com"
0xDD6a6f76eb36B873C1C184e8b9b9e762FE216490 = "https://tap-aggregator-arbitrum-one.graphops.xyz"

# DIPS (Decentralized Indexing Payment System)
# NOTE: DIPS requires Horizon mode ([horizon].enabled = true)
# Payer authorization is handled via escrow accounts (same trust model as TAP)
#
# Pricing uses human-readable GRT values (not wei), e.g. "100" = 100 GRT per 30 days.
[dips]
host = "0.0.0.0"
port = "7601"
recurring_collector = "0x4444444444444444444444444444444444444444"

# Networks you explicitly support indexing. 
# Proposals from the dipper for you to index networks that are not in the list below are rejected.
# See https://github.com/graphprotocol/networks-registry/blob/main/docs/networks-table.md
# e.g. supported_networks = ["mainnet", "arbitrum-one"]
supported_networks = []

# Minimum payment you are willing to accept in order to accept indexing agreements
# (base price + entity-based price). Total payment = base price + (entities on sg * entity_rate)
#
# For reference: analysis of subgraphs indexed by the upgrade indexer in Q1 2025 found
# the average entity size to be ~0.759 KiB. At this size, 1 billion entities â‰ˆ 0.707 TiB.
# Your own observations may differ - adjust pricing accordingly.
min_grt_per_billion_entities_per_30_days = "200"  # entity-based component (global)

[dips.min_grt_per_30_days]  # base rate component (per-network)
# arbitrum-one = "450"
# matic = "300"
# fantom = "300"
# avalanche = "225"
# bsc = "200"
# base = "80"
# gnosis = "45"
# near-mainnet = "45"
# fuji = "45"
# mainnet = "45"
# optimism = "30"
# xdai = "30"
# polygon-zkevm = "30"
# polygon-amoy = "30"
# xlayer-mainnet = "30"
# soneium = "30"
# abstract = "30"
# fantom-testnet = "30"
# lens = "30"
# rootstock-testnet = "30"
# kaia = "30"
# chiliz = "30"
# linea-sepolia = "30"
# joc-testnet = "30"
# etherlink-mainnet = "30"
# apechain = "30"
# ink = "30"
# unichain-testnet = "30"
# blast-testnet = "30"
# megaeth = "30"
# sei-atlantic = "30"
# zksync-era-sepolia = "30"
# arbitrum-nova = "30"
# hoodi = "30"
# celo-sepolia = "30"
# vana = "30"
# joc = "30"
# swellchain = "30"
# soneium-testnet = "30"
# zetachain = "30"
# hemi-sepolia = "30"
# megaeth-testnet = "30"
# iotex = "30"
# stable = "30"
# cronos = "30"
# ronin = "30"
# fraxtal = "30"
# kaia-testnet = "30"
# abstract-testnet = "30"
# neox-testnet = "30"
# fuse-testnet = "30"
# manta = "30"
# viction = "30"
# peaq = "30"
# boba-testnet = "30"
# hashkeychain = "30"
# vana-moksha = "30"
# botanix-testnet = "30"
# corn = "30"
# chiliz-testnet = "30"
# apechain-curtis = "30"
# megaeth-timothy = "30"
# status-sepolia = "30"
# etherlink-shadownet = "30"
# etherlink-testnet = "30"
# mint = "30"
# ink-sepolia = "30"
# iotex-testnet = "30"
# neox = "30"
# lumia = "30"
# mint-sepolia = "30"
# lens-testnet = "30"
# berachain = "30"
# sonic = "25"
# katana = "25"
# hemi = "20"
# zksync-era = "20"
# sei-mainnet = "20"
# scroll = "15"
# optimism-sepolia = "15"
# celo = "15"
# linea = "15"
# base-sepolia = "15"
# unichain = "15"
# monad-testnet = "10"
# monad = "10"
# fuse = "10"
# scroll-sepolia = "10"
# rootstock = "10"
# near-testnet = "10"
# moonriver = "10"
# chapel = "10"
# moonbeam = "10"
# blast-mainnet = "5"
# arbitrum-sepolia = "5"
# boba = "5"
# sepolia = "5"

[dips.additional_networks]

[horizon]
# Enable Horizon support and detection
# When enabled: checks that Horizon contracts are active via the network subgraph
# When enabled, set `blockchain.subgraph_service_address` and
# `blockchain.receipts_verifier_address_v2`
#
# Horizon is required in production.
enabled = true
