# WARNING:  This shows all the possible configuration options. Make sure you know what 
#           you are doing.
#           Prefer starting with `minimal-config-example.toml`.
#
# All the optional values (missing from the minimal config) are set to the current
# default values.
# You will have to change *most* the values below to match your setup.
#
# Some of the config below are global graph network values, which you can find here:
# https://github.com/graphprotocol/indexer/tree/main/docs/networks
#
# Pro tip: if you need to load some values from the environment into this config, you
# can use shell expansions like with `envsubst`.


[common.indexer]
indexer_address = "0x1111111111111111111111111111111111111111"
operator_mnemonic = "abondon abondon abondon abondon abondon abondon abondon abondon abondon abondon abondon abondon abondon abondon abondon"

[common.server]
# Host and port to serve the indexer-service query endpoint. This one should have a
# public ingress.
host_and_port = "0.0.0.0:7600"
# Host and port to serve the indexer-service metrics. This one should stay private.
metrics_host_and_port = "0.0.0.0:7300"
# URL prefix for the query endpoint.
url_prefix = "/"

[common.database]
# The URL of the Postgres database used for the indexer components. The same database
# that is used by the `indexer-agent`. It is expected that `indexer-agent` will create
# the necessary tables.
postgres_url = "postgresql://indexer@postgres:5432/indexer_components_0"

[common.graph_node]
# URL to your graph-node's status endpoint
status_url = "http://graph-node:8030/graphql"
# URL to your graph-node's query endpoint
query_base_url = "http://graph-node:8000"

[common.network_subgraph]
# Serve the network subgraph on `common.server.host_and_port`/network
serve_subgraph = false
# Optional, deployment to look for in the local `graph-node`, if locally indexed.
# Locally indexing the subgraph is recommended.
deployment = "Qmaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
# Query URL for the Graph Network subgraph.
query_url = "http://example.com/network-subgraph"
# Refreshing interval for the Graph contracts information from the Graph Network
# subgraph.
syncing_interval = 60
# Amount of time to keep treating an allocation as active after it has been closed.
# So that we can keep serving queries while the information about the allocation closure
# propagates to all the consumers.
recently_closed_allocation_buffer_seconds = 3600

[common.escrow_subgraph]
# Serve the escrow subgraph on `common.server.host_and_port`/escrow
serve_subgraph = false
# Optional, deployment to look for in the local `graph-node`, if locally indexed.
# Locally indexing the subgraph is recommended.
deployment = "Qmbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"
# Query URL for the Escrow subgraph.
query_url = "http://example.com/escrow-subgraph"
# Refreshing interval for the Escrow contracts information from the Escrow subgraph.
syncing_interval = 60
# Amount of time to keep treating an allocation as active after it has been closed.
# So that we can keep serving queries while the information about the allocation closure
# propagates to all the consumers.
recently_closed_allocation_buffer_seconds = 3600

[common.graph_network]
id = 1
# The chain ID of the network that the graph network is running on
chain_id = 99999999999999

[common.scalar]
# The chain ID of the network that the graph network is running on
# Should be the same as the chain ID of the network that the graph network is running on
chain_id = 99999999999999
# Contract address of TAP's receipt aggregate voucher (RAV) verifier.
receipts_verifier_address = "0x2222222222222222222222222222222222222222"
# Timestamp error tolerance for incoming query receipts. If a query receipt timestamp
# is outside now() +/- timestamp_error_tolerance, the query is rejected.
timestamp_error_tolerance = 30
